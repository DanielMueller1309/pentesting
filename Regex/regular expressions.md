#RegEx

- Regular expressions are a set of characters used to check patterns(Muster) in strings
- They are also called 'regexp' and 'regex'
## Basic
### Symbol	Descriptions
- `.`	replaces/match any character except(außer) linebreaks
- `^`	matches start of string if `^(x)`negativate if `[^x]`. First search für x at start of string secound define no __x__ has to be in the string
- `$`	matches end of string
- `*`	matches up zero or more times the preceding character
- `+` vorrangegangenes zeichen kannn merhmals aber mindestens einmal vorkommen
- `\`	Wird nach einem eigentlich in Regex genutzen Zeichen gesucht wird dieses Zeichen Vorangestellt Maskierung muss hierbei aber nur auserhalb von Eckigen klammern erfolgen
- `()`	Groups regular expressions
- `?`	Das vorhergehende Element kann vorkommen, muss aber nicht
- `[]` Sucht Dinge herraus die in den Klammern vorkommen
- `{}` min to max des vorgängers (Interval Regex)
- `|` gibt alternativen an nur eine kann es sein

#### Beispiel:

#### ^ und $
`cat <Beipieldatei> | grep a`
sucht nach dem buchstaben a in der Gesammten Datei
- `^a` sucht dabei nur am anfang eines Strings
- `a$`sm ende

##### Interval Regular expressions
`{n}`
Matches the preceding character appearing 'n' times exactly

`{n,m}`
Matches the preceding character appearing 'n' times but not more than m

`{n, }`
Matches the preceding(vorgänger) character only when it appears 'n' times or more
##### Platzhalter
`Max .*Mustermann`
Der "__.__" gibt an das nach Max und dem Lehrzeichen ein beliebiges Zeichen folgen kann Sei es ein B. o.Ä. für den zweiten Vornamen und __*__ gibt an das es belibig viele zeichen sein können, zum beispiel aber auch gar keins.

##### Alternativen
`Das Wetter ist (toll|richtig schlecht)`
In diesem Beispiel dürfen als letzte Worte "toll" oder "richtig schlecht" vorkommen, aber nicht beide.

##### Mehrmaliges auftreten
`cat <Beispieldatei> | grep -E a{2}`
Zeigt an wo __a__ zweimal hintereinander Vorkommt
[`-E`](/Programme/grep.md) muss hierbei mit angegeben werden

`[1-9][0-9]{0,2}[a-z]?`
__{0,2}__ erlaubt das das vorangegangene Argument 0 mal bis max 2 mal vorkommen kann
`[1-9][0-9]{1,4}[a-z]?`
__{1,4}__ besagt das das das vorangegangene Argument mindesten Vorkommen muss und somit eine zwei Ziffern lange Zahl eine Mindestanforderung ist.

##### Verschachtelung
`(VW (Golf|Polo)|Fiat (Punto|Panda))`
gibt Fahreuge aus die ein VW Golf oder Polo bzw ein Fiat Punto oder Panda ist.

`(10|01)+`
Beschreibt eine Folge aus Nullen und Einsen, in der maximal 2 Nullen oder Einsen aufeinander folgen. (Falls das jetzt nicht direkt klar wird: einfach mal überlegen, was man aus "10" und "01" zusammensetzen kann.)

##### Referenzen
Es gibt sehr nützliche Verwendungszwecke für Gruppen. Stell dir vor, du willst in einer Folge von Zahlen (sagen wir sie seien mit einem Leerzeichen voneinander getrennt) all die Zahlen finden, die mit der selben Ziffer beginnen und enden.

Wir haben also
> 129 337873 78324 43938 9388 824998 349734

Dazu können wir solch einen Ausdruck verwenden:
` ([0-9])[0-9]*\1 `
wobei das \1 auf den Inhalt der ersten Klammer verweist (referenziert) und daher an der Stelle von \1 das selbe stehen muss wie in dieser Klammer. Das erste und letzte Zeichen unseres Ausdrucks ist jeweils ein Leerzeichen, um damit das Ende und den Anfang einer Zahl zu kennzeichnen.

Nutze [regexr](https://regexr.com/) umd dies nachzuvolziehen.

Wie du siehst, zählt das erste und letzte Leerzeichen auch immer noch zu dem jeweiligen Treffer dazu. Das ist auch kein Wunder, schließlich steht vor und hinter unserem Ausdruck auch jeweils ein Leerzeichen. Das ist nicht wirklich gut, wenn uns dieses Leerzeichen eigentlich gar nicht interessiert. Daher stellt die RegEx-Sprache auch hier ein Mittel zur Verfügung, welches auch funktioniert, wenn wir keine Gruppen benutzen möchten oder können:

##### Modifikatoren
In allen RegEx-Varianten kannst du sogenannte Modifikatoren setzen und damit das genaue Verhalten des Ausdrucks kontrollieren. In Java kannst du dies z.B. bei der Konstruktion eines matcher-Objektes erledigen, bei PHP hat ein regulärer Ausdruck immer die Syntax
_[Begrenzungszeichen][RegEx][Begrenzungszeichen][Modifikator(en)]_
also z.B.
`/(Mein|Ausdruck)/im`
Dabei sind die Slashes die Begrenzungszeichen (andere sind hier denkbar, z.B. ~), und __i__ und __m__ in diesem Fall Modifikatoren. Gängige Modifikatoren sind unter anderem:

- __i__  Case-Insensitivity (die Nichtbeachtung von Groß- und Kleinschreibung) einschalten
- __s__ Punkt wird multilinefähig: Der Punkt frisst auch Zeilenumbrüche, dies ist standardmäßig nicht so.
- __m__ Zeilenmodus: Die Zeichen ^ und $ matchen auch auf Zeilenanfänge bzw. -enden. Ohne den Modifikator passen sie nur auf Anfang und Ende der gesamten Zeichenkette.
Modifikatoren beziehen sich immer auf den ganzen Ausdruck und sind daher eine leicht übersehene Fehlerquelle.

##### Spezielle Zeichen
Großer Buchstabe immer Gegenteil eines kleinen.
- `\w \W`
Ein Wort-Zeichen (kleines w) steht genau für [a-zA-Z0-9_] und ein Nichtwortzeichen (großes W) steht genau für alles andere, also [^a-zA-Z0-9_].

- `\d \D`
Ein Digit, also eine Ziffer von 0-9. Entspricht damit [0-9] und in der Großschreibung [^0-9].

- `\b \B`
  Wortgrenzen
  > 129 337873 78324 43938 9388 824998 349734

  obigen Ausdruck ohne die Leerzeichen:

  `\b([0-9])[0-9]*\1\b`

  __\b__ ist ein zusammengehöriges Element und kennzeichnet ein Wortanfang oder ein Wortende (also eine Wortgrenze)
  Suche nach "Kai" (ohne __\b__)
  **Kai** fährt nach
  **Kai**serslautern
  mit **\b**:
  **Kai** fährt nach
  Kaiserslautern

Letzteres ließe sich in regulären Ausdrücken so umsetzen bzw. ausdrücken:
  `\bKai\b`

Ein großes B steht dementsprechend für alle Stellen, an denen keine Wortgrenze auftritt.

- `\s \S`
Die Kleine Variante steht für alle Whitespaces: Das sind so gut wie alle Zeichen, die man nicht sieht. Also Return (bzw. Enter), Leertaste (Space), Tab(ulator).


##Brace Expansion
The syntax for brace expansion is either a sequence or a commax3 separated list of items inside curly braces "{}". The starting and ending items in a sequence are separated by two periods "..".

###Beispiel:
`echo {aa,bb,cc,dd}`
Output: aa bb cc dd

`echo {0..11}`
Output: 0 1 2 3 4 5 6 7 8 9 10 11

`echo {a..d}`
Output: a b c d

`echo a{0..5}b`
Output: a0b a1b a2b a3b a4b a5b

###Links:
https://www.guru99.com/linux-regular-expressions.html#1
https://regexr.com/

https://www.dev-insider.de/regex-zum-suchen-und-ersetzen-nutzen-a-840347/

[Gut erklärt](https://danielfett.de/2006/03/20/regulaere-ausdruecke-tutorial/)

http://marius-gerum.de/uploads/downloads/regex_tut.pdf
https://regex101.com/
